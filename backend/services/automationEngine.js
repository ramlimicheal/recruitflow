const pool = require('../config/database');\nconst schedule = require('node-schedule');\n\n/**\n * Automation Engine\n * Automatically creates tasks based on defined rules\n * Runs every hour to check for pending actions\n */\n\nclass AutomationEngine {\n  constructor(io) {\n    this.io = io;\n    this.job = null;\n  }\n\n  // Start the scheduler\n  start() {\n    console.log('Automation Engine started');\n    // Run every hour\n    this.job = schedule.scheduleJob('0 * * * *', () => {\n      console.log('Running automation rules...');\n      this.runRules();\n    });\n    // Also run immediately on startup\n    this.runRules();\n  }\n\n  // Stop the scheduler\n  stop() {\n    if (this.job) {\n      this.job.cancel();\n      console.log('Automation Engine stopped');\n    }\n  }\n\n  // Main rule execution\n  async runRules() {\n    try {\n      await this.checkStageDel ayRule();\n      await this.checkClientContactRule();\n      await this.checkInterviewUnconfirmedRule();\n      await this.checkOfferPendingRule();\n    } catch (err) {\n      console.error('Error running automation rules:', err);\n    }\n  }\n\n  // RULE 1: Candidate in same stage > 2 days\n  async checkStageDelayRule() {\n    try {\n      const result = await pool.query(\n        `SELECT c.*, u.name as owner_name, cl.name as client_name\n         FROM candidates c\n         JOIN users u ON c.owner_id = u.id\n         JOIN clients cl ON c.client_id = cl.id\n         WHERE c.days_in_stage > 2 AND c.stage NOT IN ('joined', 'rejected')`\n      );\n\n      for (const candidate of result.rows) {\n        // Check if task already exists today\n        const existing = await pool.query(\n          `SELECT id FROM tasks WHERE candidate_id = $1 AND title LIKE 'Follow up%' AND created_at::date = CURRENT_DATE`,\n          [candidate.id]\n        );\n\n        if (existing.rows.length === 0) {\n          // Create follow-up task\n          const taskResult = await pool.query(\n            `INSERT INTO tasks (title, description, priority, candidate_id, client_id, task_type, assigned_to_id, is_auto_generated)\n             VALUES ($1, $2, $3, $4, $5, $6, $7, true) RETURNING *`,\n            [\n              `Follow up with ${candidate.client_name} on ${candidate.name}'s feedback`,\n              `${candidate.name} has been in ${candidate.stage} stage for ${candidate.days_in_stage} days. Check status with client.`,\n              'High',\n              candidate.id,\n              candidate.client_id,\n              'Call',\n              candidate.owner_id\n            ]\n          );\n\n          // Create notification\n          await pool.query(\n            `INSERT INTO notifications (user_id, notification_type, message, related_entity_type, related_entity_id)\n             VALUES ($1, $2, $3, $4, $5)`,\n            [\n              candidate.owner_id,\n              'task_assigned',\n              `Auto-generated: Follow up on ${candidate.name} (${candidate.days_in_stage}d in stage)`,\n              'candidate',\n              candidate.id\n            ]\n          );\n\n          // Emit to team\n          this.io?.emit('task-auto-created', {\n            task: taskResult.rows[0],\n            candidateName: candidate.name,\n            recruiter: candidate.owner_name\n          });\n        }\n      }\n    } catch (err) {\n      console.error('Error in stage delay rule:', err);\n    }\n  }\n\n  // RULE 2: Client not contacted > 7 days\n  async checkClientContactRule() {\n    try {\n      const result = await pool.query(\n        `SELECT c.*, u.name as account_manager\n         FROM clients c\n         JOIN users u ON c.account_manager_id = u.id\n         WHERE (c.last_contact IS NULL OR c.last_contact < NOW() - INTERVAL '7 days')\n         AND c.status NOT IN ('Churned', 'Dormant')`\n      );\n\n      for (const client of result.rows) {\n        // Check if check-in task exists\n        const existing = await pool.query(\n          `SELECT id FROM tasks WHERE client_id = $1 AND title LIKE 'Check-in%' AND status != 'Completed' AND created_at > NOW() - INTERVAL '7 days'`,\n          [client.id]\n        );\n\n        if (existing.rows.length === 0) {\n          // Create check-in task\n          const taskResult = await pool.query(\n            `INSERT INTO tasks (title, description, priority, client_id, task_type, assigned_to_id, is_auto_generated)\n             VALUES ($1, $2, $3, $4, $5, $6, true) RETURNING *`,\n            [\n              `Check-in call with ${client.name}`,\n              `Haven't contacted ${client.name} for ${Math.floor((Date.now() - new Date(client.last_contact)) / (1000 * 60 * 60 * 24))} days. Ask about new openings.`,\n              'Medium',\n              client.id,\n              'Call',\n              client.account_manager_id\n            ]\n          );\n\n          // Create notification\n          await pool.query(\n            `INSERT INTO notifications (user_id, notification_type, message, related_entity_type, related_entity_id)\n             VALUES ($1, $2, $3, $4, $5)`,\n            [\n              client.account_manager_id,\n              'task_assigned',\n              `Auto-generated: Time to check in with ${client.name}`,\n              'client',\n              client.id\n            ]\n          );\n\n          this.io?.emit('task-auto-created', {\n            task: taskResult.rows[0],\n            clientName: client.name,\n            recruiter: client.account_manager\n          });\n        }\n      }\n    } catch (err) {\n      console.error('Error in client contact rule:', err);\n    }\n  }\n\n  // RULE 3: Interview scheduled but unconfirmed > 24 hours\n  async checkInterviewUnconfirmedRule() {\n    try {\n      const result = await pool.query(\n        `SELECT i.*, c.name as candidate_name, c.owner_id\n         FROM interviews i\n         JOIN candidates c ON i.candidate_id = c.id\n         WHERE i.status = 'Pending' AND i.created_at < NOW() - INTERVAL '24 hours'`\n      );\n\n      for (const interview of result.rows) {\n        const existing = await pool.query(\n          `SELECT id FROM tasks WHERE title LIKE '%${interview.candidate_name}%' AND title LIKE 'Confirm%' AND created_at::date = CURRENT_DATE`,\n          []\n        );\n\n        if (existing.rows.length === 0) {\n          const taskResult = await pool.query(\n            `INSERT INTO tasks (title, description, priority, task_type, assigned_to_id, is_auto_generated)\n             VALUES ($1, $2, $3, $4, $5, true) RETURNING *`,\n            [\n              `Confirm interview with ${interview.candidate_name}`,\n              `Interview scheduled for ${new Date(interview.interview_date).toLocaleDateString()} but not yet confirmed.`,\n              'High',\n              'Call',\n              interview.owner_id\n            ]\n          );\n\n          await pool.query(\n            `INSERT INTO notifications (user_id, notification_type, message)\n             VALUES ($1, $2, $3)`,\n            [\n              interview.owner_id,\n              'task_assigned',\n              `Auto-generated: Confirm interview with ${interview.candidate_name}`\n            ]\n          );\n\n          this.io?.emit('task-auto-created', {\n            task: taskResult.rows[0],\n            interviewCandidate: interview.candidate_name\n          });\n        }\n      }\n    } catch (err) {\n      console.error('Error in interview confirmation rule:', err);\n    }\n  }\n\n  // RULE 4: Offer pending signature > 2 days\n  async checkOfferPendingRule() {\n    try {\n      // Assuming we track offer status in a separate table or candidates.stage\n      const result = await pool.query(\n        `SELECT c.*, u.name as owner_name\n         FROM candidates c\n         JOIN users u ON c.owner_id = u.id\n         WHERE c.stage = 'offer_pending' AND c.last_updated < NOW() - INTERVAL '2 days'`\n      );\n\n      for (const candidate of result.rows) {\n        const existing = await pool.query(\n          `SELECT id FROM tasks WHERE candidate_id = $1 AND title LIKE 'Request offer%' AND created_at::date = CURRENT_DATE`,\n          [candidate.id]\n        );\n\n        if (existing.rows.length === 0) {\n          const taskResult = await pool.query(\n            `INSERT INTO tasks (title, description, priority, candidate_id, task_type, assigned_to_id, is_auto_generated)\n             VALUES ($1, $2, $3, $4, $5, $6, true) RETURNING *`,\n            [\n              `Request offer letter from ${candidate.client}`,\n              `${candidate.name}'s offer has been pending for 2+ days. Follow up with client for offer letter.`,\n              'High',\n              candidate.id,\n              'Email',\n              candidate.owner_id\n            ]\n          );\n\n          await pool.query(\n            `INSERT INTO notifications (user_id, notification_type, message, related_entity_type, related_entity_id)\n             VALUES ($1, $2, $3, $4, $5)`,\n            [\n              candidate.owner_id,\n              'task_assigned',\n              `Auto-generated: Follow up on offer for ${candidate.name}`,\n              'candidate',\n              candidate.id\n            ]\n          );\n\n          this.io?.emit('task-auto-created', {\n            task: taskResult.rows[0],\n            candidateName: candidate.name\n          });\n        }\n      }\n    } catch (err) {\n      console.error('Error in offer pending rule:', err);\n    }\n  }\n}\n\nmodule.exports = AutomationEngine;\n"